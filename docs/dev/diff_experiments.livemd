# Diff Experiments

```elixir
Mix.install(
  [
    :kino,
    :owl,
    {:mneme, path: Path.expand("../../", __DIR__)}
  ],
  consolidate_protocols: false
)
```

## Introduction

This notebook is intended as a development aid for understanding what's going on under the hood when a semantic diff is performed. In particular, I'd like to:

* Better understand & improve the cost model
  * See multiple diff possibilities along with their costs (this will require some changes to the diff algo)
  * Connect cost constants to some dynamic input such that it can be iterated on while providing visibility into how those changes affect the result
* Fix cases where the diff algo allows syntactic transformations that create confusing diffs, like removing a branch, removing some nodes, "sliding an existing node" and adding the same branch back.

```elixir
alias Mneme.Diff
alias Mneme.Diff.{AST, Delta, Formatter, SyntaxNode}
alias Mneme.Diff.Zipper, as: Z
:ok
```

### An example to work with

I'm going to start with a simplified version of the example from [gh#45](https://github.com/zachallaun/mneme/issues/45), where the current diff algorithm does some weird stuff.

```elixir
original = """
{:"::", [line: 1, column: 5],
 [
   {{:., [line: 1, column: 5], [Kernel, :to_string]},
    [closing: [line: 1, column: 10], line: 1, column: 5], [{:var, [line: 1, column: 5], :binary}]}
 ]}
"""

modified = """
{:"::", [line: 1, column: 5, closing: [line: 1, column: 10]],
 [{:var, [line: 1, column: 5], :binary}]}
"""
```

```elixir
KinoDiff.new(original, modified)
```

### Example 1

We're going to compare these two code blocks:

<!-- livebook:{"force_markdown":true} -->

```elixir
{
  nil,
  [{:sequences, :uhh}, {:sequences, :green}, :this_must_be_here]
} <- foo()

# compare to

{
  [{:sequences, :red}],
  [{:sequences, :uhh}]
} <- foo()
```

```elixir
original = """
{
  nil,
  [{:sequences, :uhh}, {:sequences, :green}, :this_must_be_here]
} <- foo()
"""

modified = """
{
  [{:sequences, :red}],
  [{:sequences, :uhh}]
} <- foo()
"""

:persistent_term.erase(:delta_cost_fun)
:persistent_term.erase(:delta_heuristic_fun)
KinoDiff.new(original, modified)
```

Let's modify the cost function:

```elixir
non_adjacent_penalty = fn
  %{adjacent?: true} -> 0
  %{adjacent?: false} -> 10
end

cost = fn %Delta{} = delta ->
  case delta do
    %{changed?: false, kind: :node, depth_difference: dd} ->
      dd + 1 + non_adjacent_penalty.(delta)

    %{changed?: false, kind: :branch, depth_difference: dd} ->
      dd + 10 + non_adjacent_penalty.(delta)

    %{changed?: true, kind: :branch} ->
      300

    %{changed?: true, kind: :node} = delta ->
      290 + 160 * Delta.node(delta).n_descendants
  end
end

:persistent_term.put(:delta_cost_fun, cost)
KinoDiff.new(original, modified)
```

Let's modify the heuristic, keeping the new cost function:

```elixir
heuristic = fn {_, _, d1}, {_, _, d2} ->
  case {d1, d2} do
    # penalize changing the same side repeatedly
    {%{changed?: true, side: :left}, %{changed?: true, side: :left}} -> 10
    {%{changed?: true, side: :right}, %{changed?: true, side: :right}} -> 10
    # default
    _ -> 0
  end
end

:persistent_term.put(:delta_heuristic_fun, heuristic)
KinoDiff.new(original, modified)
```

### Example 2

Let's try with the cost/heuristic functions above.

```elixir
original = """
{:"::", [line: 1, column: 5],
 [
   {{:., [line: 1, column: 5], [Kernel, :to_string]},
    [closing: [line: 1, column: 10], line: 1, column: 5], [{:var, [line: 1, column: 5], :binary}]}
 ]}
"""

modified = """
{:"::", [line: 1, column: 5, closing: [line: 1, column: 10]],
 [{:var, [line: 1, column: 5], :binary}]}
"""

KinoDiff.new(original, modified)
```
