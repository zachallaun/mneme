# Diff Experiments

```elixir
Mix.install(
  [
    :kino,
    :owl,
    {:mneme, path: Path.expand("../../", __DIR__)}
  ],
  consolidate_protocols: false
)
```

## Introduction

This notebook is intended as a development aid for understanding what's going on under the hood when a semantic diff is performed. In particular, I'd like to:

* Better understand & improve the cost model
  * See multiple diff possibilities along with their costs (this will require some changes to the diff algo)
  * Connect cost constants to some dynamic input such that it can be iterated on while providing visibility into how those changes affect the result
* Fix cases where the diff algo allows syntactic transformations that create confusing diffs, like removing a branch, removing some nodes, "sliding an existing node" and adding the same branch back.

```elixir
alias Mneme.Diff
alias Mneme.Diff.{AST, Delta, Formatter, SyntaxNode}
alias Mneme.Diff.Zipper, as: Z
Kino.nothing()
```

### An example to work with

I'm going to start with a simplified version of the example from [gh#45](https://github.com/zachallaun/mneme/issues/45), where the current diff algorithm does some weird stuff.

```elixir
original = """
{:"::", [line: 1, column: 5],
 [
   {{:., [line: 1, column: 5], [Kernel, :to_string]},
    [closing: [line: 1, column: 10], line: 1, column: 5], [{:var, [line: 1, column: 5], :binary}]}
 ]}
"""

modified = """
{:"::", [line: 1, column: 5, closing: [line: 1, column: 10]],
 [{:var, [line: 1, column: 5], :binary}]}
"""

{:ok, {left, right}} = Diff.format(original, modified)

left
|> Owl.Data.unlines()
|> Owl.IO.puts()

right
|> Owl.Data.unlines()
|> Owl.IO.puts()

Kino.nothing()
```

## Helpers

```elixir
defmodule Helpers do
  def kino_pagination(renderables) do
    renderables
    |> Enum.with_index(&{&2 + 1, &1})
    |> Kino.Layout.tabs()
  end
end
```

```elixir
import Helpers
```

```elixir
defmodule KinoDiff do
  alias Mneme.Diff
  alias Mneme.Diff.Delta
  alias Mneme.Diff.SyntaxNode

  @colors [
    ins: [:white, :green_background],
    ins_highlight: [:white, :green_background, :bright],
    del: [:white, :red_background],
    del_highlight: [:white, :red_background, :bright],
    match: [:white, :light_black_background]
  ]

  defstruct [:highlighted]

  def new(left_code, right_code) do
    diff_steps(left_code, right_code)
    |> Enum.with_index(&{&2 + 1, &1})
    |> Kino.Layout.tabs()
  end

  def diff_steps(left_code, right_code) do
    {left, right} = SyntaxNode.from_strings!(left_code, right_code)
    path = Diff.shortest_path({left, right, nil})

    path
    |> Enum.reverse()
    |> diff_steps(left_code, right_code)
    |> Enum.reverse()
  end

  defp diff_steps([_ | rest] = path, left_code, right_code) do
    {left_changed, right_changed} = Diff.split_sides(path)

    left_ins = Diff.to_instructions(left_changed, :del)
    right_ins = Diff.to_instructions(right_changed, :ins)

    step =
      {highlight(left_code, left_ins), highlight(right_code, right_ins)}
      |> render(path)

    [step | diff_steps(rest, left_code, right_code)]
  end

  defp diff_steps([], _, _), do: []

  def highlight(code, instructions) do
    text =
      code
      |> Diff.Formatter.highlight_lines(instructions, colors: @colors)
      |> Owl.Data.unlines()
      |> Owl.Data.to_ansidata()
      |> IO.iodata_to_binary()

    %__MODULE__{highlighted: text}
  end

  def render({left, right}, [delta | _] = path) do
    cost = path |> Enum.map(&Delta.cost/1) |> Enum.sum()

    Kino.Layout.grid([
      Kino.Markdown.new("**Current cost:** #{cost}"),
      render_delta(delta),
      Kino.Layout.grid([left, right], columns: 2)
    ])
  end

  defp render_delta(%{changed?: false, kind: kind}) do
    """
    **Matched #{kind}**
    """
    |> Kino.Markdown.new()
  end

  defp render_delta(%{changed?: true, kind: kind, side: side} = delta) do
    node = Delta.node(delta)
    tag = node.parent && elem(node.parent, 0)

    """
    **Changed #{kind}** (#{side}, cost #{Delta.cost(delta)}, parent #{tag})
    """
    |> Kino.Markdown.new()
  end

  defimpl Kino.Render do
    def to_livebook(%{highlighted: text}), do: {:text, text}
  end
end
```

```elixir
defmodule KinoDiffLive do
  alias Kino.Frame

  def new(original, modified) do
    frame = Frame.new()

    controls = [keyboard: Kino.Control.keyboard([:keydown])]
    Kino.render(controls[:keyboard])

    state = %{
      frame: frame,
      steps: KinoDiff.diff_steps(original, modified),
      current: 0
    }

    controls
    |> Kino.Control.tagged_stream()
    |> Kino.listen(state, &handle_event/2)

    render!(state)

    frame
  end

  def handle_event({:keyboard, event}, state) do
    state =
      case event do
        %{type: :keydown, key: "ArrowRight"} ->
          Map.update!(state, :current, &min(&1 + 1, length(state.steps) - 1))

        %{type: :keydown, key: "ArrowLeft"} ->
          Map.update!(state, :current, &max(&1 - 1, 0))

        _ ->
          state
      end

    render!(state)

    {:cont, state}
  end

  defp render!(%{frame: frame, steps: steps, current: idx}) do
    step = Enum.at(steps, idx)

    content =
      Kino.Layout.grid([
        Kino.Text.new("<- #{idx + 1} of #{length(steps)} ->"),
        step
      ])

    Frame.render(frame, content)
  end
end
```

## Scratchpad

```elixir
KinoDiffLive.new(original, modified)
```

```elixir
original = """
auto_assert {:foo,
             [
               [
                 %Tag{data: "~", sequences: [:green]},
                 %Tag{data: "X", sequences: [:green]},
                 "\\"foo\\""
               ]
             ]} <- format(~S|"foo"|, ~S|~X"foo"|)
"""

modified = """
auto_assert {[[%Tag{data: "\\"foo\\"", sequences: [:red]}]],
             [[%Tag{data: "~X\\"foo\\"", sequences: [:green]}]]} <- format(~S|"foo"|, ~S|~X"foo"|)
"""

KinoDiffLive.new(original, modified)
```

```elixir
alias Mneme.Diff
alias Mneme.Diff.{SyntaxNode, Delta}
alias Mneme.Diff.Zipper, as: Z

next_once = fn l, r ->
  {l_popall, r_popall} = {SyntaxNode.pop_all(l), SyntaxNode.pop_all(r)}

  case {l_popall, r_popall} do
    {%{null?: true, parent: {:pop_both, p1}} = left,
     %{null?: true, parent: {:pop_both, p2}} = right} ->
      if SyntaxNode.similar_branch?(p1, p2) do
        {SyntaxNode.next_sibling(p1), SyntaxNode.next_sibling(p2)}
      else
        {left, right}
      end

    {left, right} ->
      {left, right}
  end
end

summarize_z = fn z ->
  case Z.node(z) do
    {form, meta, list} when is_list(list) ->
      {form, Map.take(meta, [:line, :column]), :...}

    {form, meta, val} ->
      {form, Map.take(meta, [:line, :column]), val}

    list when is_list(list) ->
      [:...]

    {_, _} ->
      {:..., :...}

    other ->
      other
  end
end

log_nodes = fn d ->
  [
    changed?: d.changed?,
    side: d.side,
    left_before: summarize_z.(d.left_node.zipper),
    left_after: summarize_z.(d.left_node.zipper),
    right_before: summarize_z.(d.right_node.zipper),
    right_after: summarize_z.(d.right_node.zipper)
  ]
  |> IO.inspect()
end
```

```elixir
{left, right} = SyntaxNode.from_strings!(original, modified)
path = Diff.shortest_path({left, right, nil})

d = Enum.at(path, 19)

log_nodes.(d)

# next_l = SyntaxNode.next_sibling(d.left_node)

# {l1, r1} = next_once.(next_l, d.right_node)
# {l1, r1} = next_once.(l1, r1)
# {l1, r1} = next_once.(l1, r1)
# {l1, r1} = next_once.(l1, r1)
# {l, r} = next_once.(l1, r1)

# IO.puts(l == l1 && r == r1)

# d2 = Enum.at(path, 18)

# d2.right_node
```

```elixir
{_, p} = d.right_node.parent
p.zipper |> Z.up()
```
